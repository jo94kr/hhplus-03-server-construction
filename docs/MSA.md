# MSA 전환을 통한 서비스 분리 및 트랜잭션 처리 설계

---

## 목차

* [서론](#서론)
* [기존 시스템 분석 및 트랜잭션 범위](#기존-시스템-분석-및-트랜잭션-범위)
* [서비스 분리 설계](#서비스-분리-설계)
  + [좌석예약](#좌석예약)
  + [결제](#결제)
  + [잔액 충전/차감](#잔액-충전차감)
* [트랜잭션 처리의 한계](#트랜잭션-처리의-한계)
* [해결방안](#해결방안)
  + [Spring Event를 이용한 비동기 트랜잭션 처리](spring-event를-이용한-비동기-트랜잭션-처리)
  + [2PC (Two-Phase Commit) 패턴](#2pc-twophase-commit-패턴)
  + [SAGA 패턴](#saga-패턴)
    - [코레오그래피 기반 사가 (Choreography-based Saga)](#코레오그래피-기반-사가-choreography-based-saga)
    - [오케스트레이션 기반 사가 (Orchestration-based Saga)](#오케스트레이션-기반-사가-orchestration-based-saga)
  + [Outbox 패턴](#outbox-패턴)
  + [SAGA 패턴과 Outbox 패턴의 결합](#saga-패턴과-outbox-패턴의-결합)
* [결론](#결론)

---

## 서론

기존 단일 서비스 구조에서 마이크로서비스 아키텍쳐(MSA)로 전환하여 서비스의 확장성을 확보하려면 어떻게 할지 설계해 보고 이 과정에서 발생할 수 있는 트랜잭션 처리 문제와 그 해결 방안을 고려해 본다.

---

## 기존 시스템 분석 및 트랜잭션 범위

현재 서비스 구조는 모놀리틱 아키텍쳐로 구성되어 있고 주요 기능은 다음과 같다.

- 좌석예약
  ```java
	좌석예약_Tx() {
		사용자_조회();
		콘서트_좌석_조회/임시_예약_처리();
		콘서트_예약();
		데이터_플랫폼_전송();
	}
	```
- 결제
  ```java
  결제_Tx() {
      결제_가능여부_체크();
      사용자_조회();
      잔액차감();
      결제처리();
      예약_상태_변경();
      토큰_만료_처리();
  }
  ```
- 잔액 충전/차감
    ```java
	충전/차감_Tx() {
		사용자_조회();
		잔액_충전/차감();
	}
	```

서비스가 확장되어 예약, 결제, 사용자, 토큰, 데이터 플랫폼 등으로 분리될 경우, 모든 로직이 완전히 실행되어야 트랜잭션이 완료되기 때문에 성능 저하가 발생할 수 있다. 특히 결제 과정에서 외부 PG 혹은 외부 데이터 플랫폼 서비스를 이용할 때, 외부 서비스의 예기치 못한 오류로 인해 트랜잭션이 실패하면 이전에 수행된 모든 로직이 롤백될 위험이 있다. 이러한 상황에서는 각 도메인의 책임을 명확히 분리하고, 트랜잭션이 다른 도메인에 미치는 영향을 최소화할 수 있는 이벤트 기반 처리 방식이 필요하다. 그러나 트랜잭션이 분리됨에 따라 데이터 일관성 문제와 오류 발생 시 롤백 처리(`보상 트랜잭션`)의 어려움이 예상된다.

---

## 서비스 분리 설계

### 좌석예약

좌석 상태를 변경하고 예약 내역을 생성하는 것이 좌석 예약 서비스의 주요 책임이다. 이 두 가지 작업은 하나의 트랜잭션 주기 내에서 처리되어야 하며, 둘 중 하나만 처리되면 안 된다. 따라서 좌석 예약 서비스는 분리 설계에 적합하지 않다고 판단된다.

### 결제

기존 결제 로직은 트랜잭션이 길어 성능 저하가 발생할 가능성이 있다. 이를 개선하기 위해 트랜잭션 분리가 필요하다. 결제 로직을 분리할 때, 결제 결과에 따라 잔액 차감, 예약 상태 변경 등의 보상 트랜잭션을 어떻게 처리할지 고려해야 한다. 결제와 예약 상태 변경의 책임을 분리하는 것이 바람직하며, 예약 상태가 `완료`로 변경되지 않으면 결제가 롤백되어야 한다.

```java
// 결제 요청과 잔액 차감을 하나의 트랜잭션으로 처리한다.
결제처리_Tx() {
	결제_정보_조회(); 
	유저_정보_조회(); 
	사용자_잔액_차감();
	예약_처리_이벤트();
}

// 결제 및 잔액 차감이 완료된 후 예약 상태 변경은 비동기 이벤트로 처리한다.
예약_처리_Tx() {
	예약_상태_변경()
}
```

### 잔액 충전/차감

잔액 충전/차감 로직은 현재 분리할 부분이 없다. 다만, 추후에 충전/차감 로그를 남길 경우, 로그는 충전/차감에 대한 책임이 없다고 판단된다. 따라서 충전/차감 로그는 별도의 트랜잭션으로 처리하여, 로그 기록이 실패하더라도 충전/차감에는 영향을 미치지 않도록 한다.

```java
충전/차감_Tx() {
	사용자_조회();
	잔액_충전/차감();
	충전/차감_로그_처리_이벤트();
}

// 충전/차감 로직과 별개로 동작하도록 한다.
충전/차감_로그_처리_Tx() {
	충전/차감_로그();
}
```

---

## 트랜잭션 처리의 한계

서비스가 분리됨에 따라 다음과 같은 트랜잭션 처리의 한계가 발생할 수 있다.
- 트랜잭션 일관성 문제
  - 기존 모놀리틱 환경에서는 DBMS가 트랜잭션의 원자성과 일관성을 보장해 주었지만 MSA에선 각각의 마이크로 서비스이 트랜잭션 여러개가 묶여서 만들어지므로 DBMS가 지원하는 트랜잭션을 통해 일관성 유지가 어려워진다. (일부 마이크로 서비스가 실패하면 데이터 일관성이 깨짐)
- 오류 처리 및 롤백 문제
  - 하나의 마이크로 서비스에서 오류가 발생할 경우, 다른 서비스에서 이미 수행된 작업을 롤백하기 복잡하다.


---
## 해결방안

### Spring Event를 이용한 비동기 트랜잭션 처리

스프링 이벤트(Spring Event)는 스프링 프레임워크에서 제공하는 경량화된 이벤트 발행 및 수신 메커니즘. 이를 통해 서비스 간 비동기 통신을 구현하고, 트랜잭션 간의 느슨한 결합을 가능하게 할 수 있다.

스프링 이벤트는 크게 `이벤트 발행자`(Event Publisher)와 `이벤트 리스너`(Event Listener)로 구성

- **이벤트 발행자(Event Publisher)**: 서비스 내에서 특정 작업이 완료되면 해당 작업에 대한 이벤트를 발행
- **이벤트 리스너(Event Listener)**: 발행된 이벤트를 구독하고, 이를 처리하는 작업을 수행

스프링 이벤트를 사용하면 서비스 간의 직접적인 호출 없이도 비동기적으로 작업을 처리할 수 있어서 서비스 간의 결합도를 낮출 수 있다. 이 방식을 사용하면 트랜잭션 처리가 간결해지고, 특히 SAGA 패턴의 코레오그래피 방식과 유사한 동작을 할 수 있다.

```java
@RedissonLock(value = "#reservationConcertCommand.concertSeatIdList")  
public ReservationConcertResult setConcertReservation(ReservationConcertCommand reservationConcertCommand) {  
    // 좌석 예약 로직
    // ...
    
    // 데이터 플랫폼 전송 이벤트 발행
    applicationEventPublisher.publishEvent(new ReservationInfoEvent(reservation));  
  
    return ReservationConcertResult.from(reservation);  
}
```

- 장점:
  - 의존성을 분리하여 두 클래스를 느슨하게 결합시킬 수 있음
  - 클래스가 독립적이므로 재사용성을 높일 수 있음
  - 메세지 구독 모듈을 추가 또는 삭제할 때, 다른 모듈에 영향을 주지 않은 채로 수정할 수 있음
- 단점:
  - 코드 흐름을 따라가기 어려움
  - 전체적인 이벤트의 구독 및 발행 과정을 테스트하기 어려움
  - 메세지 구독 순서를 고려해야 하는 경우 복잡해짐
  - 단일 애플리케이션 내에서 이벤트가 발행되고 수신하는 구성이므로 분산 환경에서는 추가적인 메시지 브로커 등이 필요함

### 2PC (Two-Phase Commit) 패턴

이전에는 분산 트랜잭션 문제를 해결하기 위해 2PC(Two-Phase Commit) 패턴을 사용했다. 2PC는 코디네이터와 여러 데이터베이스 간의 합의를 통해 트랜잭션 커밋/롤백이 결정된다.

1. **준비 단계 (Phase 1)**: 글로벌 트랜잭션에 참여하는 모든 데이터베이스가 커밋이 가능한 상태 혹은 불가능한 상태임을 코디네이터에게 알린다.
2. **커밋 단계 (Phase 2)**: 코디네이터가 커밋 또는 롤백을 수행한다.

하지만 2PC는 다음과 같은 이유로 MSA에서는 많이 사용되지 않는다:

- Lock을 사용하므로 성능이 저하된다.
- NoSQL 등 일부 DBMS가 지원하지 않으면 사용할 수 없다.
- 이종의 DBMS에서는 사용하기 어렵다.
- MSA에서 마이크로 서비스는 각자의 데이터베이스를 소유하고, 다른 서비스와 Public API를 통해 데이터를 제공하기 때문에, 여러 데이터베이스에 걸친 글로벌 트랜잭션을 관리하는 구조와 맞지 않는다.
- 코디네이터에 의존적이어서, 코디네이터 장애 시 각 데이터베이스가 커밋/롤백 여부를 스스로 결정할 수 없다.

### SAGA 패턴

SAGA 패턴은 MSA와 같은 분산 아키텍처에서 데이터 일관성을 보장하기 위해 등장한 설계 패턴이다. SAGA 패턴에서는 연속된 개별 서비스의 로컬 트랜잭션이 이어져, 전체 비즈니스 트랜잭션을 구성한다. 첫 번째 트랜잭션이 완료되면 두 번째 트랜잭션이 트리거되고, 두 번째 트랜잭션이 완료되면 세 번째 트랜잭션이 트리거되는 방식이다. 이 과정이 하나의 무용담(saga)과 같아서 SAGA라는 이름이 붙여졌다.

SAGA 패턴에서는 개별 서비스가 실패했을 때 보상 트랜잭션을 발생시켜 이를 상쇄한다. SAGA 패턴에서는 데이터 일관성을 관리하는 주체가 DBMS가 아닌 애플리케이션. 보상 트랜잭션이 적용되기 전까지는 일시적으로 데이터 정합이 깨질 수 있지만, 보상 트랜잭션이 완료되면 '결과적 정합'을 보장한다.

SAGA 패턴은 크게 코레오그래피 기반 사가와 오케스트레이션 기반 사가로 구분된다.
#### 코레오그래피 기반 사가 (Choreography-based Saga)

각 서비스는 트랜잭션이 완료되면 완료 이벤트를 발행한다. 다음 로컬 트랜잭션을 수행해야 할 서비스는 해당 이벤트를 구독하고 이어서 실행한다. 중간에 로컬 트랜잭션이 실패하면, 보상 트랜잭션 이벤트를 발생시켜 롤백을 시도한다.

- **장점**:
  - 한 서비스에 문제가 발생해도 나머지 시스템이 영향을 덜 받는다.
- **단점**:
  - 참가자가 많으면 트랜잭션 흐름이 복잡해진다.
  - 서비스 간 순환 종속성이 발생할 수 있다.
  - 서비스 간 결합도가 높다.

#### 오케스트레이션 기반 사가 (Orchestration-based Saga)

중앙 집중된 Saga Orchestrator가 SAGA 참여자들에게 어떤 로컬 트랜잭션을 실행해야 하는지 알려주는 방식이다. 오케스트레이터가 모든 트랜잭션을 처리하고, 필요하면 보상 트랜잭션을 발생시켜 롤백을 시도한다.

- **장점**:
  - 트랜잭션 흐름이 명확하다.
  - 서비스 간 결합도가 낮다.
- **단점**:
  - 오케스트레이터가 SPOF(Single Point Of Failure)가 될 수 있다.
  - 확장성과 유연성이 낮아질 수 있다.

SAGA 패턴의 트랜잭션은 격리되지 않는다. 데이터베이스 트랜잭션은 ACID(Atomicity, Consistency, Isolation, Durability)를 보장하지만, SAGA 패턴에서의 트랜잭션은 Isolation을 보장하지 않기 때문에 이를 보완하기 위한 설계가 필요하다.

### Outbox 패턴

Outbox 패턴은 트랜잭션의 일부로 데이터베이스에 메시지를 저장하는 방식이다. 이후 별도의 프로세스가 저장된 이벤트를 읽어 메시지 브로커에 전송한다. 이를 통해 분산 시스템에서 데이터 일관성을 유지할 수 있다.

- **구성요소**:

  - **Sender**: 메시지를 보내는 서비스
  - **Database**: 엔티티 및 메시지 outbox를 저장하는 데이터베이스
  - **Message outbox**: 보낼 메시지를 저장하는 테이블 (관계형 데이터베이스의 경우)
  - **Message relay**: outbox에 저장된 메시지를 메시지 브로커로 보내는 서비스
- **작동 방식**:

  1. 애플리케이션이 데이터베이스의 outbox 테이블에 메시지 내용을 저장한다.
  2. 다른 애플리케이션이나 프로세스가 outbox 테이블에서 데이터를 읽고, 메시지 브로커에 전송한다.
  3. 실패 시 메시지가 성공적으로 전송될 때까지 재시도한다.

Outbox 패턴은 메시지를 적어도 한 번 이상 성공적으로 전송할 수 있도록 보장한다.

- **장점**:

  - 데이터 일관성을 유지할 수 있다.
  - 메시지가 적어도 한 번 이상 전송되었는지 확인할 수 있다.
- **단점**:

  - 추가적인 테이블과 프로세스가 필요하다.
  - 구현 복잡도가 증가할 수 있다.
  - 여러 서비스 간 트랜잭션 관리에 한계

Outbox 패턴을 구현할 때는 Polling publisher와 Transaction log tailing 두 가지 방식이 있다. Polling publisher는 주기적으로 outbox 테이블을 폴링하여 메시지를 전송하고, Transaction log tailing은 데이터베이스의 트랜잭션 로그를 모니터링하여 메시지를 전송한다.

### SAGA 패턴과 Outbox 패턴의 결합

SAGA 패턴과 Outbox 패턴을 결합하면 분산 시스템에서 데이터 일관성과 트랜잭션 관리를 효과적으로 할 수 있다. SAGA 패턴을 통해 분산 트랜잭션을 관리하고, Outbox 패턴을 통해 메시지의 신뢰성을 보장할 수 있다.

1. **트랜잭션 처리 단계**:

  - 결제 서비스가 결제 요청과 사용자 잔액 차감을 하나의 트랜잭션으로 묶어 처리.
  - 예약 서비스가 결제 성공 이벤트를 받아 예약 상태를 변경.
2. **Outbox 패턴 적용**:

  - 결제 서비스가 결제 성공 이벤트를 outbox 테이블에 저장.
  - 별도의 Message relay가 outbox 테이블에서 이벤트를 읽어 메시지 브로커로 전송.

---

## 결론

MSA로 전환하면서 발생할 수 있는 트랜잭션 처리 문제는 다양한 패턴과 기술을 통해 해결할 수 있다. 그러나 분산 환경에서 데이터 일관성을 보장하기 위해서는 Kafka와 같은 메시지 브로커를 도입해 일관성을 유지할 필요가 있다. 이벤트 기반 로직을 구현하는 과정에서 트랜잭션을 완전히 분리하고, 데이터의 원자성을 보장해야 할 작업과 비동기로 처리할 수 있는 작업을 명확히 구분하는 것이 중요하다는 것을 알게 되었다. 적절한 패턴을 사용해 도메인 간 결합도와 트랜잭션을 효과적으로 분리함으로써 유연하고 안정적인 서비스를 구축할 수 있을 것이다.

---
