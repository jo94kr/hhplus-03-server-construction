# MSA 전환을 통한 서비스 분리 및 트랜잭션 처리 설계

---

## 목차

* [서론](#서론)
* [기존 시스템 분석 및 트랜잭션 범위](#기존-시스템-분석-및-트랜잭션-범위)
* [서비스 분리 설계](#서비스-분리-설계)
    + [좌석예약](#좌석예약)
    + [결제](#결제)
    + [잔액 충전/차감](#잔액-충전차감)
* [트랜잭션 처리의 한계](#트랜잭션-처리의-한계)
* [해결방안](#해결방안)
    + [2PC (Two-Phase Commit) 패턴](#2pc-two-phase-commit-패턴)
    + [SAGA 패턴](#saga-패턴)
        - [코레오그래피 기반 사가 (Choreography-based Saga)](#코레오그래피-기반-사가-choreography-based-saga)
        - [오케스트레이션 기반 사가 (Orchestration-based Saga)](#오케스트레이션-기반-사가-orchestration-based-saga)
    + [Outbox 패턴](#outbox-패턴)
    + [SAGA 패턴과 Outbox 패턴의 결합](#saga-패턴과-outbox-패턴의-결합)

---

## 서론

기존 단일 서비스 구조에서 마이크로서비스 아키텍쳐(MSA)로 전환하여 서비스의 확장성을 확보하려면 어떻게 할지 설계해 보고 이 과정에서 발생할 수 있는 트랜잭션 처리 문제와 그 해결 방안을 고려해 본다.

---

## 기존 시스템 분석 및 트랜잭션 범위

현재 서비스 구조는 모놀리틱 아키텍쳐로 구성되어 있고 주요 기능은 다음과 같다.

- 좌석예약
  ```java
	좌석예약() {
		사용자_조회();
		콘서트_좌석_조회/임시_예약_처리();
		콘서트_예약();
		데이터_플랫폼_전송();
	}
	```
- 결제
  ```java
  결제() {
      결제_가능여부_체크();
      사용자_조회();
      잔액차감();
      결제처리();
      예약_상태_변경();
      토큰_만료_처리();
  }
  ```
- 잔액 충전/차감
    ```java
	충전/차감() {
		사용자_조회();
		잔액_충전/차감();
	}
	```

서비스가 추후에 확장 된다면 예약, 결제, 사용자, 토큰, 데이터 플랫폼으로 분리가 될 것으로 예상된다.
분리했을때 예상되는 문제점으로는 트랜잭션 분리로인한 일관성 문제, 오류가 발생했을때 롤백 처리 등이 있을것이다.

---

## 서비스 분리 설계

### 좌석예약

좌석 상태를 변경하고 예약 내역을 생성하여 반환하는 것이 좌석예약 서비스의 주요 책임이다. 이 두 가지 작업은 하나의 트랜잭션 주기 내에서 처리되어야 하고 둘 중 하나만 처리되면 안 된다고 생각한다.

그러므로 좌석예약은 분리 설계에는 적합하지 않다고 판단.

### 결제

기존 결제 로직에서는 처리할 것들이 많은 만큼 잡고 있는 트랜잭션 또한 길어졌다. 이를 개선하기 위해 트랜잭션 분리가 필요하다고 판단했다.
결제 로직을 분리할 때 고려해야 할 사항으로 결제 결과에 따라 잔액 차감, 예약 상태 변경 등의 트랜잭션들의 보상 트랜잭션은 어떻게 처리할지 고려해야 한다. 그리고 결제와 예약 상태 변경의 책임을 분리하는 것이 바람직하다고 생각한다. 다만 예약 상태가 `완료` 로 변경되지 않으면 결제는 롤백 되어야 한다.

```java
// 결제 요청과 잔액 차감을 하나의 트랜잭션으로 처리한다.
결제처리() {
	결제_정보_조회(); 
	유저_정보_조회(); 
	사용자_잔액_차감();
}

// 결제 및 잔액 차감이 완료된 후 예약 상태 변경은 비동기 이벤트로 처리한다.
예약_처리() {
	예약_상태_변경()
}
```

### 잔액 충전/차감

잔액 충전/차감의 경우 기존 로직에선 분리할 부분이 없다. 다만 추후에 충전/차감 로그를 남긴다고 했을 때 로그의 경우 충전/차감에 대한 책임이 없다고 판단.
별도의 트랜잭션으로 충전/차감 로그가 실패 하든 안하든 충전/차감은 영향을 받지 않도록 한다.

```java
충전/차감() {
	사용자_조회();
	잔액_충전/차감();
	
}

// 충전/차감 로직과 별개로 동작하도록 한다.
충전/차감_로그_처리() {
	충전/차감_로그();
}
```

---

## 트랜잭션 처리의 한계

위에서 설계한 대로 서비스가 분리됨에 따라 다음과 같은 트랜잭션 처리의 한계가 발생한다.
- 트랜잭션 일관성 문제
    - 기존 모놀리틱 환경에서는 DBMS가 트랜잭션의 원자성과 일관성을 보장해 주었지만 MSA에선 각각의 마이크로 서비스이 트랜잭션 여러개가 묶여서 만들어지므로 DBMS가 지원하는 트랜잭션을 통해 일관성 유지가 어려워진다. (일부 마이크로 서비스가 실패하면 데이터 일관성이 깨짐)
- 오류 처리 및 롤백 문제
    - 하나의 마이크로 서비스에서 오류가 발생할 경우, 다른 서비스에서 이미 수행된 작업을 롤백하기 복잡하다.


---
## 해결방안

### 2PC (Two-Phase Commit) 패턴

이전에는 분산 트랜잭션 문제를 해결하기 위해 2PC(Two-Phase Commit) 패턴을 사용했다. 2PC는 코디네이터와 여러 데이터베이스 간의 합의를 통해 트랜잭션 커밋/롤백이 결정된다.

1. **준비 단계 (Phase 1)**: 글로벌 트랜잭션에 참여하는 모든 데이터베이스가 커밋이 가능한 상태 혹은 불가능한 상태임을 코디네이터에게 알린다.
2. **커밋 단계 (Phase 2)**: 코디네이터가 커밋 또는 롤백을 수행한다.

하지만 2PC는 다음과 같은 이유로 MSA에서는 많이 사용되지 않는다:

- Lock을 사용하므로 성능이 저하된다.
- NoSQL 등 일부 DBMS가 지원하지 않으면 사용할 수 없다.
- 이종의 DBMS에서는 사용하기 어렵다.
- MSA에서 마이크로 서비스는 각자의 데이터베이스를 소유하고, 다른 서비스와 Public API를 통해 데이터를 제공하기 때문에, 여러 데이터베이스에 걸친 글로벌 트랜잭션을 관리하는 구조와 맞지 않는다.
- 코디네이터에 의존적이어서, 코디네이터 장애 시 각 데이터베이스가 커밋/롤백 여부를 스스로 결정할 수 없다.

### SAGA 패턴

SAGA 패턴은 MSA와 같은 분산 아키텍처에서 데이터 일관성을 보장하기 위해 등장한 설계 패턴이다. SAGA 패턴에서는 연속된 개별 서비스의 로컬 트랜잭션이 이어져, 전체 비즈니스 트랜잭션을 구성한다. 첫 번째 트랜잭션이 완료되면 두 번째 트랜잭션이 트리거되고, 두 번째 트랜잭션이 완료되면 세 번째 트랜잭션이 트리거되는 방식이다. 이 과정이 하나의 무용담(saga)과 같아서 SAGA라는 이름이 붙여졌다.

SAGA 패턴에서는 개별 서비스가 실패했을 때 보상 트랜잭션을 발생시켜 이를 상쇄한다. 즉, SAGA 패턴에서는 데이터 일관성을 관리하는 주체가 DBMS가 아닌 애플리케이션임을 알 수 있다. 보상 트랜잭션이 적용되기 전까지는 일시적으로 데이터 정합이 깨질 수 있지만, 보상 트랜잭션이 완료되면 '결과적 정합'을 보장한다.

SAGA 패턴은 크게 코레오그래피 기반 사가와 오케스트레이션 기반 사가로 구분된다.
#### 코레오그래피 기반 사가 (Choreography-based Saga)

각 서비스는 트랜잭션이 완료되면 완료 이벤트를 발행한다. 다음 로컬 트랜잭션을 수행해야 할 서비스는 해당 이벤트를 구독하고 이어서 실행한다. 중간에 로컬 트랜잭션이 실패하면, 보상 트랜잭션 이벤트를 발생시켜 롤백을 시도한다.

- **장점**:
    - 구성이 간단하다.
    - 한 서비스에 문제가 발생해도 나머지 시스템이 영향을 덜 받는다.
- **단점**:
    - 참가자가 많으면 트랜잭션 흐름이 복잡해진다.
    - 서비스 간 순환 종속성이 발생할 수 있다.
    - 서비스 간 결합도가 높다.

#### 오케스트레이션 기반 사가 (Orchestration-based Saga)

중앙 집중된 Saga Orchestrator가 SAGA 참여자들에게 어떤 로컬 트랜잭션을 실행해야 하는지 알려주는 방식이다. 오케스트레이터가 모든 트랜잭션을 처리하고, 필요하면 보상 트랜잭션을 발생시켜 롤백을 시도한다.

- **장점**:
    - 트랜잭션 흐름이 명확하다.
    - 서비스 간 결합도가 낮다.
- **단점**:
    - 오케스트레이터가 SPOF(Single Point Of Failure)가 될 수 있다.
    - 확장성과 유연성이 낮아질 수 있다.

SAGA 패턴의 트랜잭션은 격리되지 않는다. 데이터베이스 트랜잭션은 ACID(Atomicity, Consistency, Isolation, Durability)를 보장하지만, SAGA 패턴에서의 트랜잭션은 Isolation을 보장하지 않기 때문에 이를 보완하기 위한 설계가 필요하다.

### Outbox 패턴

Outbox 패턴은 트랜잭션의 일부로 데이터베이스에 메시지를 저장하는 방식이다. 이후 별도의 프로세스가 저장된 이벤트를 읽어 메시지 브로커에 전송한다. 이를 통해 분산 시스템에서 데이터 일관성을 유지할 수 있다.

- **구성요소**:

    - **Sender**: 메시지를 보내는 서비스
    - **Database**: 엔티티 및 메시지 outbox를 저장하는 데이터베이스
    - **Message outbox**: 보낼 메시지를 저장하는 테이블 (관계형 데이터베이스의 경우)
    - **Message relay**: outbox에 저장된 메시지를 메시지 브로커로 보내는 서비스
- **작동 방식**:

    1. 애플리케이션이 데이터베이스의 outbox 테이블에 메시지 내용을 저장한다.
    2. 다른 애플리케이션이나 프로세스가 outbox 테이블에서 데이터를 읽고, 메시지 브로커에 전송한다.
    3. 실패 시 메시지가 성공적으로 전송될 때까지 재시도한다.

Outbox 패턴은 메시지를 적어도 한 번 이상 성공적으로 전송할 수 있도록 보장한다.

- **장점**:

    - 데이터 일관성을 유지할 수 있다.
    - 메시지가 적어도 한 번 이상 전송되었는지 확인할 수 있다.
- **단점**:

    - 추가적인 테이블과 프로세스가 필요하다.
    - 구현 복잡도가 증가할 수 있다.
    - 여러 서비스 간 트랜잭션 관리에 한계

Outbox 패턴을 구현할 때는 Polling publisher와 Transaction log tailing 두 가지 방식이 있다. Polling publisher는 주기적으로 outbox 테이블을 폴링하여 메시지를 전송하고, Transaction log tailing은 데이터베이스의 트랜잭션 로그를 모니터링하여 메시지를 전송한다.

### SAGA 패턴과 Outbox 패턴의 결합

SAGA 패턴과 Outbox 패턴을 결합하면 분산 시스템에서 데이터 일관성과 트랜잭션 관리를 효과적으로 할 수 있다. SAGA 패턴을 통해 분산 트랜잭션을 관리하고, Outbox 패턴을 통해 메시지의 신뢰성을 보장할 수 있다.

1. **트랜잭션 처리 단계**:

    - 결제 서비스가 결제 요청과 사용자 잔액 차감을 하나의 트랜잭션으로 묶어 처리.
    - 예약 서비스가 결제 성공 이벤트를 받아 예약 상태를 변경.
2. **Outbox 패턴 적용**:

    - 결제 서비스가 결제 성공 이벤트를 outbox 테이블에 저장.
    - 별도의 Message relay가 outbox 테이블에서 이벤트를 읽어 메시지 브로커로 전송.

---
